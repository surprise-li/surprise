<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>itcastmark:C:\Users\lichengxiang\Desktop\MD\Knowledge\知识点</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="js-">js复习</h1>
<h2 id="-js-">一、js数据类型/流程控制</h2>
<h3 id="-">数据类型</h3>
<pre><code>    1.简单数据类型（栈）
        (1)string;(2)number;特殊值:NaN (3)boolean;(4)undefined;
        1.1 typeof
        typeof 用于检测简单数据的类型;
        1.2 数据类型之间的转换
            1.2.1 其他数据类型转number
                a.Number()
                    可用于任何数据类型转number
                    **注意点**
                    1.（）里面的内容可看成数字就可以转我Number;如果不是数值，则会转为NaN;
                    2.（）里面是数值，但是数值之间有空格，也会转为NaN;
                    3.（）为空或者是空格，会转换为0；
                b.parseInt()
                    专用于字符串的转换;
                    **注意点**
                    1.（）里面的内容从左往右查找开始转换，如果遇到数字转为数字就会转为Number类型，一旦遇到非数字,则停止转换
                    2.（）里面如果为空，则会转为NaN;
                    3.（）里面的字符串如果是小数，那么只会转换整数部分；
                c.parseFloat()
                    与parseInt()用法相类似，唯一区别是parseFloat()可以转换小数部分

            1.2.2 其他数据类型转string
                a.string()
                    string(obj)// 可以转null 和 undefined;
                b.toString()
                    obj.toString() // 不能转 null 和 undefined;

            1.2.3 其他数据类型转boolean
                a. 对需要转换的内容进行算数运算
                b. 在需要转换的内容前面加 ‘+’
                c. Boolean()
                    null,空字符串,false,0,NaN,undefined   可以转为false;
                    *空格会转为ture;

    2.复杂数据类型（堆）
        （1）Array (2) object (3) Data对象 (4) function(){} (5)null
</code></pre><h3 id="math-">Math对象</h3>
<pre><code>    1.2.1 Math.pow(a,b)  a的b次方
    1.2.2 Math.round()  四舍五入
    1.2.3 Math.ceil()   向上取整
    1.2.4 Math.floor()   向下取整
    1.2.5 Math.max()   最大值
    1.2.6 Math.min()   最小值
    1.2.7 Math.random()   随机生成一个0~1之间的数字
</code></pre><h3 id="-">运算符的比较</h3>
<pre><code>    1.如果两个值具有相同的类型，那么就检测他的等同性.
    2.如果两个值的类型不同，则用以下规则
        2.1 如果一个值类型是null,另一个值类型是undefined;  则他们相等
        2.2 如果一个值是数字，另一个是字符串，则将字符串转化为数值再进行比较
        2.3 如果一个是true,将它转为1；在进行比较,false也一样；
        2.4 如果一个值是对象，另一个值数字或字符串，将对象转换成原始类型的值，在进行比较
        2.5 其他的数值组合是不相等的；
</code></pre><h3 id="-">选择结构</h3>
<ul>
<li>if(){          }</li>
<li>if(){          }else{  }</li>
<li>if(){   }else if(){        }else{            }</li>
<li>switch( ){ case: ; break}</li>
<li>三元表达式   A&gt;B ? tur : false;</li>
</ul>
<h3 id="-">循环结构</h3>
<ul>
<li>for(var i = ?; i &lt; ? ; i++){    }</li>
<li>while( ){ 循环体 }</li>
<li><p>do{ 循环体 }while( )</p>
<pre><code> 循环中的break和continue;
     1.循环中，如果遇到break,就会结束当前的循环；
     2.循环中，如果遇到continue,就会结束当前次的循环，但仍进行下一次循环；
</code></pre></li>
</ul>
<h2 id="array-string-">Array()方法&amp;&amp;String对象方法</h2>
<h3 id="-">数组的方法</h3>
<pre><code>    2.1.1 数组的长度
        arr.length;
        清空数组的方法：（1）arr.length = 0; (2) arr = [];

    2.1.2 concat() 
        方法用于链接合并多个数组，
        var a = [1,2,3]; a.concat(4,5); ==&gt; 1,2,3,4,5

    2.1.3 join() 
        用于把数组中的所有元素放入一个字符串。
        arr[0] = &quot;George&quot;
        arr[1] = &quot;John&quot;
        arr[2] = &quot;Thomas&quot;
        arr.join() ==&gt; George,John,Thomas;
        join()中可以放入分隔符，输出结果就是以括号内分隔符分隔的字符串

    2.1.4 pop() 
        用于删除并返回数组的最后一个元素。
        var arr = new Array(3)
            arr[0] = &quot;George&quot;
            arr[1] = &quot;John&quot;
            arr[2] = &quot;Thomas&quot;

            arr.pop() ==&gt; &quot;Thomas&quot;
        arr ==&gt; [&quot;George&quot;,&quot;John&quot;]

    2.1.5 push()
        向数组的末尾添加一个或多个元素，并返回新的长度。
        var arr = new Array(3)
            arr[0] = &quot;George&quot;
            arr[1] = &quot;John&quot;
            arr[2] = &quot;Thomas&quot;

        arr.push(&#39;sandy&#39;);
        arr ==&gt; [&quot;George&quot;,&quot;John&quot;,&quot;Thomas&quot;,&quot;sandy&quot;]

    2.1.5 shift() 
        用于把数组的第一个元素从其中删除，并返回第一个元素的值。
        var arr = new Array(3)
            arr[0] = &quot;George&quot;
            arr[1] = &quot;John&quot;
            arr[2] = &quot;Thomas&quot;

        arr.shift() ==&gt; &quot;George&quot;
        arr ==&gt; [John,Thomas];

    2.1.6 unshift() 
        可向数组的开头添加一个或更多元素，并返回新的长度。
        var arr = new Array()
            arr[0] = &quot;George&quot;
            arr[1] = &quot;John&quot;
            arr[2] = &quot;Thomas&quot;

        arr.unshift(&quot;sandy&quot;);
        arr ==&gt; [&quot;sandy&quot;,&quot;George&quot;,&quot;John&quot;,&quot;Thomas&quot;]

    2.1.7 reverse()
        颠倒数组中元素的顺序。

    2.1.8 slice()
        可从已有的数组中返回选定的元素；可用于提取数组的某一部分；
        var arr = new Array(3)
            arr[0] = &quot;George&quot;
            arr[1] = &quot;John&quot;
            arr[2] = &quot;Thomas&quot;
            arr[3] = &quot;James&quot;
            arr[4] = &quot;Adrew&quot;
            arr[5] = &quot;Martin&quot;

        arr.slice(2,4) ==&gt;Thomas,James  end索引上的数组不会被截取
        arr ==&gt;George,John,Thomas,James,Adrew,Martin //也就是，slice不会改变数组的长度，并不会修改数组！

    2.1.9 splice()
        方法用于插入、删除或替换数组的元素
        arr.splice(从何处删除/添加元素,删除或添加的数量,向数组中添加的元素(可以是多个元素))

        splice() 方法会直接对数组进行修改！
</code></pre><h4 id="es5-">ES5新增的数组方法</h4>
<ul>
<li><p>forEach()</p>
<p>  arr.forEach(function(item,index,arr){});//forEach没有返回值，返回的只有undefined;</p>
</li>
<li><p>map()</p>
<p>  arr.map(function(item,index,arr){});//可以设置返回值，return的值组成新数组；</p>
</li>
<li><p>filter()</p>
<p>  过滤数组，返回新过滤后的数组.</p>
<p>  arr.filter(function(item,index,arr){ if(){return true}else{return false}});</p>
</li>
</ul>
<h3 id="-string-">字符串String对象的方法</h3>
<pre><code>    2.2.1 charAt()
        返回指定索引位置上的字符；
        var str=&quot;Hello world!&quot;
            str.charAt(1) ==&gt; e;

    2.2.2 concat()
        链接字符串; 类比数组中的concat();

    2.2.3 indexOf() 
        返回某个指定的字符串值在字符串中(首次)出现的位置;如果找不到该字符，则会返回-1；
        var str=&quot;Hello world!&quot;
        str.indexOf(&#39;H&#39;) ==&gt; 0;

    2.2.4 lastIndexOf()
        类比 indexOf()  返回一个指定的字符串值最后出现的位置

    2.2.5 replace() 
        用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串；
        string.replace(regexp/substr规定子字符串或要替换的模式,replacement规定了替换文本)

    2.2.6 slice() 
        提取字符串的某个部分，并以新的字符串返回被提取的部分；
        str.slice(start,end);
        类比数组中的slice()方法；

        类似的还有：substring();substr;

    2.2.7 trim()
        去掉字符串首位的空格

    2.2.8 split()
        将字符串以某种分隔符分隔并以数组方式返回；
        类比数组中join();与之相反
</code></pre><h2 id="function">function</h2>
<h3 id="-">函数的定义</h3>
<pre><code>        函数的定义：(1) function fn(){    };  (2) var fn = function(){    };   (3) 构造函数   
            function fn(){ };
            var F1 = new fn();
</code></pre><hr>
<h3 id="-">函数的返回值</h3>
<pre><code>        函数中的return关键字，return可以结束当前函数，可以设置函数的返回值；
    如果return后没有跟内容，返回undefined;如果函数内容没有写return,返回的也是undefined;
</code></pre><ul>
<li><strong>构造函数中设置返回值的情况</strong></li>
<li><pre><code> 1）.如果返回值是一个基本数据类型，则会被忽略；
 2）.如果返回的是一个复杂数据类型，则会返回该数据类型，将new关键字创建的对象替换！
</code></pre></li>
</ul>
<hr>
<h3 id="-">作用域</h3>
<pre><code>    js中作用域：（1）全局作用域：script标签里面，任意的函数外部。（2）局部作用域：任意的函数内（在js中，只有函数能分割作用域。）；
</code></pre><h2 id="date-">Date对象</h2>
<pre><code>        var date = new Date();        
        年  ---   date.getFullYear()
        月  ---   date.getMonth()+1  //默认月份从0开始计算，如要获取当前月份则需要进行+1；
        日  ---   date.getDete();
        小时 ---   date.getHours();
        分   ---   date.getMinutes();
        秒   ---   date.getSeconds();
</code></pre><h2 id="object">Object</h2>
<h3 id="-">对象的创建</h3>
<pre><code>    (1) var obj = new Object();
        obj.name = &quot;sandy&quot;;
        obj.age = &quot;20&quot;;
        获取对象中的属性： 1） obj.name    2)  obj[&quot;name&quot;]

    (2) var obj = {&quot;name&quot;:&quot;sandy&quot;,&quot;age&quot;:&quot;20&quot;}
</code></pre><h3 id="forin-">forin 遍历对象中的属性</h3>
<pre><code>    var obj = {&#39;name&#39;:&#39;sandy&#39;,&#39;age&#39;:&#39;20&#39;,&#39;skill&#39;:&#39;lovely&#39;}
        for(var key in obj){
            console.log(key + &#39;---&#39; + obj[key]);
        }
    // name---sandy;age---20;skill---lovely;
</code></pre><h2 id="dom">DOM</h2>
<h3 id="-">获取节点的几个方式</h3>
<pre><code>        1）document.getEelementById()
        2) document.getEelementByTagName() //通过标签名获取节点 获取的是一个伪数组；
        3）docuemnt.getEelementByClassName()   //通过类名获取节点 获取的也是一个伪数组；
            给一个节点设置类：ele.ClassName = &#39;&#39;;
</code></pre><h3 id="innerhtml-innertext-textcontent">innerHTML、innerText/textContent</h3>
<pre><code>    1.innerHTML
        1) 获取；可以获取标签间的内容，如果标签间只有文本的话，则是直接获取，如果标签间还有嵌套标签的话，标签名也一并获取；
        2）设置；可以给标签内嵌套内容，如果标签间还有嵌套标签，则标签会被渲染出来；

        兼容问题：没有兼容问题，所有浏览器都支持；

    2.innerText
        1) 获取；通过innerText获取内容，如果还有嵌套的标签，只获取内容！
        2) 设置；通过innerText设置内容，如果还有嵌套的标签，标签不会被渲染!会被转义成现在页面中；


        兼容问题：有兼容问题。低版本的火狐浏览器不兼容

    3.textContent
        与innerText 作用一样；

        兼容问题： 低版本的IE浏览器不兼容；
</code></pre><h3 id="dom-">DOM中的事件</h3>
<pre><code>            ele.onclick (单击)
            ele.ondblclick (双击事件)
            ele.onfocus (获取焦点事件)
            ele.onblur (失去焦点事件)
            ele.onkeydown (键盘按下事件)
            ele.onkeyup (键盘抬起事件)
            ele.onmouseover(鼠标移动事件)
            ele.onmousedown (鼠标按下事件)
            ele.onmouseup (鼠标抬起事件)
            ele.onmouseout (鼠标离开事件)
</code></pre><h3 id="dom-">DOM动态创建元素</h3>
<pre><code>    1）document.write()
    2) innerHTML
        创建大批量的标签，多用于创建展示的标签
    3）document.createElement() 重点；
</code></pre><h3 id="dom-">DOM中设置自定义属性</h3>
<pre><code>    1）设置自定义属性
        ele.setAttribute();
    2) 移除属性操作
        ele.removeAttribute();
    3) 获取属性值
        ele.getAttribute();
</code></pre><h3 id="-">节点类型判断</h3>
<pre><code>1.nodeType
    node.nodeType;//判断节点的类型；

    标签节点----1；
    属性节点----2；
    文本节点----3；
    注释节点----8；

2.nodeName
    node.nodeName;//获取节点的类型字符串格式；

    标签节点----标签名;
    属性节点----属性名；
    文本节点----#text;
    注释节点----#comment#;

3.node.Value;
    node.nodeValue;

    标签节点----null；
    属性节点----属性值；
    文本节点----文本的内容；
    注释节点----注释节点；
</code></pre><h3 id="dom-">DOM中节点的操作</h3>
<ul>
<li><p>6.6.1 获取上一个节点</p>
<pre><code>      previousSibling获取前一个节点，高级浏览器中可能或获取到空白文本节点、注释等；低版本的IE浏览器会忽略空白文本或注释；
      previousElementSibling,  高版本浏览器忽略中间的空白文本或者注释，获得标签文本；而低版本的IE不支持此方法，具有兼容性问题！

          function getPreviousEle(ele){
                  if(ele){
                      if(ele.previousElementSibling){
                          return ele.previousElementSibling;
                      }else{
                          ele = ele.previousSibling;
                          while(ele.nodeType != 1){
                              ele = ele.previousSibling;
                          }
                          return ele;
                      }
                  }
              }
</code></pre></li>
<li><p>6.6.2 获取下一个节点</p>
<pre><code>      nextSibling 高版本浏览器会获取到空字符串    低版本的IE浏览器只能获取到标签节点；
      nextElementSibling 高版本浏览器只会获取到标签字符串    低版本的IE有兼容性；

          参照上一个封装兼容！
</code></pre></li>
<li><p>6.6.3 获取第一个节点</p>
<pre><code>      firstChild   浏览器会获取到空白文本或者注释；
      firstElementChild   高版本浏览器会忽略空白文本节点和注释节点   低版本IE浏览器支持
</code></pre></li>
<li><p>6.6.4 获取元素的节点</p>
<pre><code>      childNodes   高版本的浏览器会将所有的节点获取  包括  空白文本节点、注释节点、标签节点    低版本的浏览器IE 会将空白文本节点忽略；

      children   高板的浏览器只会获取到子元素中标签节点   忽略了 空白文本节点和注释节点    低版本的浏览器IE   还是会将注释节点获取；
</code></pre></li>
<li><p>6.6.5 获取最后一个节点</p>
<pre><code>      lastChild 获取元素的最后一个节点，高版本的浏览器会获取到空白问题本，较低版本的IE浏览器会忽略空白文本节点和注释；
      lastElementChild 获取的元素最后一个节点。高版本的浏览器会忽略空白文本节点和注释。而低版本的IE浏览器不兼容
</code></pre></li>
<li><p>6.6.6  克隆节点</p>
<pre><code>      ele.cloneNode(true/false)
          false -- 表示浅度克隆，只会克隆标签及属性;
          true -- 深度克隆，会克隆标签的一切内容;
</code></pre></li>
<li><p>6.6.7  追加节点</p>
<pre><code>      ele.appendChild(增加的节点)；
      从父元素中追加节点到最后一子节点之后；
</code></pre></li>
<li><p>6.6.8  插入节点 </p>
<pre><code>      ele.insertBrfore(要插入的节点，位置）;
      从父元素中插入节点;
</code></pre></li>
<li><p>6.6.9  移除节点</p>
<pre><code>      ele.removeChild(要移除的节点)
</code></pre></li>
</ul>
<h3 id="-">定时器</h3>
<ul>
<li><p>setTimeout(fn,time);</p>
<pre><code>  间隔多少秒自后施行匿名函数里面的代码，只执行一次！

  清除定时器：
          var timeId = setTimeout();
          clearTimeout(timerId);
</code></pre></li>
<li><p>setInterval(fn,time);</p>
<pre><code>  间隔多少秒后执行匿名函数的代码，一直循环的执行！

  清楚定时器:
          var timeId = setInterval();
          clearInterval(timeId);
</code></pre></li>
</ul>
<h3 id="-">获取元素的属性值</h3>
<ul>
<li><p>1.currentstyle</p>
<pre><code>  ele.currentStyle.width/ele.currentStyle[&#39;width&#39;];

  IE支持（谷歌、火狐不支持）；
</code></pre></li>
<li><p>2.getComputedStyle</p>
<pre><code>  window.getComputedStyle(ele,null).width

  IE8不支持；
</code></pre></li>
</ul>
<h3 id="offset">offset</h3>
<pre><code>        Dom元素中，ele.style.name 获取到的属性值只能是行前的样式，不能获取到内嵌的样式；
    而offset的方式不但可以获取到行内的样式，内嵌的样式也可以获取到！
</code></pre><ul>
<li><p>1.offsetwidht/offsetheight</p>
<pre><code>  ele.offsetwidth/ele.offsetheight  获取到元素的宽度和高度;

  注意： offsetwidth/offsetheight = width/height + padding + border
</code></pre></li>
<li><p>2.offsetlLeft/offsetTop</p>
<pre><code>  ele.offsetLeft/ele.offsetTop

  获取的是自己的边框到最近定位的父级元素内边框的距离，若父级元素没有定位，则距离获取到body；

  且获取的值只能获取到整数，碰上小数则会四舍五入
</code></pre></li>
</ul>
<blockquote>
<p>offsetLeft与style.left的区别</p>
</blockquote>
<pre><code>    1.style.left 是以margin的左上角为准，而offsetLeft是以border左上角为准；
    2.style.left 只能获取行内样式；
    3.style.left 是可读写属性，而offsetLeft是只读属性；
    4.style.left 获取的是带有单位的字符串格式的属性值，offsetLeft获取的是number类型的属性值；
</code></pre><h3 id="scroll">scroll</h3>
<ul>
<li><p>1.scrollwidth/scrollheight</p>
<pre><code>  ele.scrollwidth/scrollheight = widht/height + padding + 内容超出的部分;
</code></pre></li>
<li><p>2.scrollTop/scrollLeft</p>
<pre><code>  获取的是页面被卷去的部分；

  一般都会配合window.onscroll事件一起使用！
</code></pre></li>
</ul>
<h3 id="client">client</h3>
<ul>
<li><p>clientWidth/clientHeight</p>
<pre><code>  clientWidth/clientHeight = width/hegiht + padding

  获取可视区的宽度和高度，一般用于响应式，配合window.onresize事件进行使用；
</code></pre></li>
</ul>
<h3 id="-">事件对象</h3>
<pre><code>每个元素注册事件之后，在执行事件的时候，都会有一个事件对象；

ele.onclick = function(event){ event = event || window.event }

    事件对象event,里面可以获取到很多属性;
        event.pageX/pageY;当前位置坐标到页面左上角的距离
        event.clientX/clientY;当前位置坐标到当前可视区左上角的距离
        event.type ; 检测事件的类型
        event.target;  事件的源头 ---   event.srcElement(IE8)
        event.currentTarget; 正在执行事件处理程序的当前对象
        event.which; 获取鼠标按钮触发 : 1.左键； 2.中键；  3.右键
</code></pre><h3 id="-">注册事件的另一种形式</h3>
<ul>
<li><p>addEventListener/attachEvent</p>
<pre><code>  好处是可以对同一个对象注册多个相同事件名称；

  1.ele.addEventListener(&#39;click&#39;,fn,false);//IE8不支持

  2.ele.attachEvent(&#39;onclick&#39;,fn);//仅IE8支持
</code></pre></li>
</ul>
<h3 id="-">移除事件</h3>
<pre><code>    1.removeEventListener(&#39;type&#39;,fn,false);

    2.detachEvent(on+&#39;type&#39;,fn);

    3.ele.onclick = null;
</code></pre><h3 id="-">事件冒泡</h3>
<pre><code>    当一个元素的事件被触发，同样的事件会在当前对象的所有的祖先元素中一次的被触发，
这种现象叫做事件的冒泡；

    好处：事件委托；

    清除冒泡阻止事件冒泡：event.stoppropagation;//IE8不支持
                event.cancleBubble = true;


    在js中阻止a标签的默认跳转：
        event.preventDefault();//IE8不支持
        event.returnValue = flase;
</code></pre><h3 id="-">事件捕获</h3>
<pre><code>    与事件冒泡相反，从祖先元素开始，知道目标触发；
</code></pre><h3 id="-">事件的三个阶段</h3>
<pre><code>1.捕获阶段 ---&gt; 2.目标阶段 ---&gt; 3.冒泡阶段
</code></pre><h3 id="-">正则表达式</h3>
<pre><code>1.正则的声明
var reg = new RegExp();
var ret = /定义的规则/；

2.正则的匹配
    text()
        语法：reg.text(obj)
        匹配字符串中是否存在指定的正则表达式，返回布尔值；

    exec()
        语法：reg.exec(obj)
        匹配字符串，执行成功返回相关信息的数组，如果失败返回null;

3.常用的一些正则的规则
    \d  digit   数字
    \D            非数字字符
    \s    space    不可见字符    
    \S            可见字符
    \w    word    大小写字母熟悉或_
    \W            与\w相反

4.自定义正则规则
    |              表示或
    ()           提升优先级
    []           表示匹配[]中任意的字符
    [^ ]         表示取反，出[]内字符外的字符
    [a-z]          -表示区间

5.边界
    /^ .. /        表示以什么开头；
    / .. $/     表示以什么结尾；

6.量词
    *    重复0次或多次   x&gt;=0;
    +   重复1次或多次   x&gt;=1;
    ?   重复0测或1次    x = (0||1);
    {n}  表示前面的字符出现{n}次；
    /^..$/    表示严格匹配；   
</code></pre><h2 id="bom">BOM</h2>
<pre><code>BOM--浏览器对象模型；
- window对象是javascript中的顶级对象
- 所有定义在全局作用域中的变量、函数都会变成window对象的属性和方法
- window对象的属性和方法在调用时可以省略window
</code></pre><hr>
<pre><code>- window.open(url,target,param) // target（窗口打开的位置）,param(窗口的属性，宽高等)；有返回值
- window.close()
</code></pre><h3 id="location">location</h3>
<ul>
<li><p>window.location</p>
<ul>
<li>location相当于浏览器的地址栏 // 可以将url解析成独立的代码片段</li>
<li>window.location.href = &#39;http//www.baidu.com&#39;</li>
<li>window.reload(true/false) // true:从本地缓存重新加载 ； false:从服务器重新加载数据</li>
</ul>
</li>
</ul>
<h3 id="navigator">navigator</h3>
<ul>
<li><p>window.navigator</p>
<p>  可以获取客户端的一些信息</p>
<ul>
<li>window.navigator.userAgent 获取用户电脑的版本信息</li>
<li>window.navigator.platform </li>
</ul>
</li>
</ul>
<h3 id="history">history</h3>
<ul>
<li>window.history.back() // 后退</li>
<li>window.history.forward() // 前进</li>
</ul>
<h1 id="jquery">jQuery</h1>
<pre><code>    JavaScript是一门编程语言，jquery是用JavaScript实现的一个JavaScript库，目的是简化我们的开发

    jQuery各版本的区别是：
        1.x 版本支持IE6，7，8；
        2.x 既以上不在支持IE6,7,8
</code></pre><h2 id="jquery-">jQuery的及基本使用</h2>
<h3 id="jquery-">jQuery的优点</h3>
<pre><code>    1.jQuery的入口函数可以有多个，且没有兼容性问题。
    2.容错性好。
    3.代码简介。
</code></pre><h3 id="jquery-">jQuery的入口函数</h3>
<pre><code>    1.$(function(){});
    2.$(document).ready(function(){});
</code></pre><h3 id="jquery-javascript-">jQuery与javascript的入口函数执行时机</h3>
<pre><code>    1.javascript的入口函数要等到页面中所有资源（包括文件、图片）加载完成才开始执行;
    2.jQuery的入口函数只会等待文档书加载完成就开始执行，并不会等待图片、文件的加载；

    在jQuery中，$ === jQuery;也就是说，在jQuery中，$符号可以完全让jQuery代替；
</code></pre><h3 id="jquery-dom-">jQuery对象与DOM对象之间的转换</h3>
<pre><code>    jQuery对象只能使用jQuery方法，DOM对象只能使用DOM对象方法；

    1.DOM对象转jQuery对象
        将DOM对象放在$()里面就可以将DOM对象转为jQuery对象；
</code></pre><h3 id="jquery-">jQuery的选择器</h3>
<h4 id="-">基本选择器</h4>
<ul>
<li><p>ID选择器</p>
<p>  $(&quot;#id&quot;);</p>
</li>
<li><p>类选择器</p>
<p>  $(&quot;.class&quot;);</p>
</li>
<li><p>标签选择器</p>
<p>  $(&quot;标签名&quot;);</p>
</li>
<li><p>交集、并集选择器</p>
<p>  $(&quot;div.box&quot;)/$(&quot;.box,.header&quot;);</p>
</li>
</ul>
<h4 id="-">层级选择器</h4>
<ul>
<li><p>子代选择器</p>
<p>  $(&quot;ul&gt;li&quot;)</p>
</li>
<li><p>后代选择器</p>
<p>  $(&quot;.box ul li&quot;)</p>
</li>
</ul>
<h4 id="-">过滤选择器</h4>
<ul>
<li><p>$(&#39;li&#39;).eq(index)/$(&#39;li:qe(index)&#39;);</p>
<pre><code>  表示选择索引为index的对象选择器；index的索引从0开始
</code></pre></li>
<li><p>$(&#39;li:odd&#39;)</p>
<pre><code>  获取到的li元素中，选择索引号为奇数的元素;
</code></pre></li>
<li><p>$(&#39;li:even&#39;)</p>
<pre><code>  获取到的li元素中，选择索引号为偶数的元素;
</code></pre></li>
</ul>
<h4 id="-">筛选选择器(方法)</h4>
<ul>
<li><p>$(&#39;.box&#39;).children(&#39;li&#39;)</p>
<p>  在.box中寻找子代为li标签的元素；(类似子代选择器)</p>
</li>
<li><p>$(&#39;.box&#39;).find(&#39;li&#39;)</p>
<p>  类似后代选择器</p>
</li>
<li><p>$(&quot;.box&quot;).siblings();</p>
<p>  选择.box的兄弟姐妹节点，不包括自己本身；</p>
</li>
<li><p>$(&quot;.box&quot;).parent();</p>
<p>  查找.box的父元素</p>
</li>
<li><p>$(&quot;.box&quot;).next()</p>
<p>  获取下一个节点</p>
</li>
<li><p>$(&quot;.box&quot;).prev()</p>
<p>  获取前一个节点</p>
</li>
<li><p>$(&quot;.box&quot;).nextAll()</p>
<p>  获取该节点后面的所有节点</p>
</li>
<li><p>$(&quot;.box&quot;).prevAll()</p>
<p>  获取该节点之前的所有节点</p>
</li>
</ul>
<h3 id="jquery-api">jQuery一些常用的API</h3>
<pre><code>只要是动画都有回调函数和时间；
</code></pre><h4 id="-">事件</h4>
<pre><code>    1.click(fn);
    2.dbtclick(fn);
    3.blur(fn);
    ...
</code></pre><h4 id="-">显示和隐藏</h4>
<pre><code>    1.show()
    2.hide()
    3.toggle()

    改变的样式是:opacity/display:none/widht/height
</code></pre><h4 id="-">淡入淡出</h4>
<pre><code>    1.fadeIn()
    2.fadeOut()
    3.fadeTo()
    4.fadeToggle()

    改变的样式是：opacity/display
</code></pre><h4 id="-">滑入滑出(上下拉)</h4>
<pre><code>    1.slideUp()
    2.slideDown()
    3.slideToggle()
</code></pre><h4 id="animate-">animate()</h4>
<pre><code>    animate()方法可以传入对象和回调函数
</code></pre><h4 id="css-">css()</h4>
<pre><code>    设置样式
</code></pre><h4 id="html-">html()</h4>
<pre><code>    与原生的innerHTML类似；
</code></pre><h4 id="clone-">clone()</h4>
<pre><code>    克隆节点，在jQuery中，括号里面无论是ture还是false，都表示深度克隆；true可以克隆事件，false不会克隆事件；
</code></pre><h4 id="val-">val()</h4>
<pre><code>    与原生的ele.value一样；
</code></pre><h4 id="end-">end()</h4>
<pre><code>    链式编程中向前找一个对象，只能向前一个;
</code></pre><h4 id="stop-">stop()</h4>
<pre><code>    停止当前正在执行的动画；
</code></pre><h4 id="append-appendto-">append()/appendTo()</h4>
<pre><code>    在父元素最后追加子节点
</code></pre><h4 id="prepend-">prepend()</h4>
<pre><code>    与DOM中insertBefore类似；
</code></pre><h4 id="before-after-">before()/after()</h4>
<pre><code>    在同级元素前面/后面添加元素；
</code></pre><h4 id="attr-prop-">attr()/prop()</h4>
<pre><code>    设置标签的属性；
    prop()更多适用于表单中的disable/checked/selected属性；
</code></pre><h4 id="empty-html-remove-">empty()/html(&#39;&#39;)/remove()</h4>
<pre><code>    三个方法都能清空节点内容；remove()会将整个节点删除,包括自身；
</code></pre><h3 id="-">类操作样式</h3>
<pre><code>1.addClass()
2.removeClass()
3.hasClass()//判断类，返回一个boolean值
4.toggleClass()
</code></pre><h3 id="offset-">offset()</h3>
<pre><code>    返回一个对象，有两个属性：left/top.  获取的left/top始终是以页面或body为准，与父元素是否定位无关。
    offset()是一个可读写的属性；

    注意区别:offsetLeft
        ele.offsetLeft 获取的是自己的边框到最近定位的父级元素内边框的距离，若父级元素没有定位，则距离获取到body；
</code></pre><h3 id="position-">position()</h3>
<pre><code>    position()是一个只读属性，返回一个对象，有两个属性,left/top
    position().left；  获取自身的margin到离自己最近的定位的父元素的距离；
            //类比于原生的offsetLeft,offsetleft获取的是自己边框到最近定位的父级元素内边框的距离
</code></pre><h3 id="width-height-">width()/height()</h3>
<pre><code>    获取的是可视区的宽高；不带单位；是一个可读写的属性方法；
</code></pre><h3 id="scrolltop-scrollleft-">scrollTop()/scrollLeft()</h3>
<pre><code>    页面被卷去的距离，是可读写属性；

    注意区分：
        scroll()是个事件
</code></pre><h3 id="jquery-">jQuery注册事件</h3>
<ul>
<li><p>简单事件绑定</p>
<p>  click();
  blur();
  mouseenter();
  mouseleave();
  dbclick();
  change();
  focus();
  keydown();</p>
</li>
<li><p>bind方式（1.7以后的jQuery版本被On取代，不推荐使用）</p>
<pre><code>  作用：给匹配到的元素直接绑定事件

  //绑定单击事件处理程序
  $(&#39;ele&#39;).bind(&#39;click&#39;,function(){});

  与简单事件绑定方式的优势：
      可以同时绑定多个事件，如：$(&#39;ele&#39;).bind(&#39;click mouseleave&#39;,function(){});

  缺点：要绑定事件的元素必须存在文档中；也就是不能给动态添加的元素注册事件
</code></pre></li>
<li><p>delegate方式</p>
<pre><code>  特点：支持动态创建的元素添加事件;可实现事件委托；

  //参数1        要绑定事件的元素
  //参数2        事件类型
  //参数3        事件处理函数
  $(&#39;ele&#39;).delegate(&#39;p&#39;,&#39;click&#39;,function(){});

  缺点是不能个自己注册事件，但是能实现事件委托；
</code></pre></li>
<li><p>on</p>
<pre><code>  on注册事件几乎拥有了前面其他所有注册事件方式的优点；
  $(&#39;ele&#39;).on(type,target,data,function(){})
  //第一个参数        事件类型；
  //第二个参数        执行事件的对象，也就是实现了事件委托
  //第三个参数        传递给处理函数的数据，事件触发的时候可以通过event.data来获取使用
  //第四个参数        事件处理函数
</code></pre></li>
</ul>
<h3 id="-">事件解绑</h3>
<ul>
<li><p>bind/delegate</p>
<p>  unbind()/undelegate()方式来解绑
  无参数的时候解绑所有的事件，有参数解绑对应参数的事件</p>
</li>
<li><p>on</p>
<p>  on注册事件使用off()方法来接触事件绑定
  //off()        </p>
<pre><code>  解绑匹配元素的所有事件
</code></pre><p>  //off(&#39;click&#39;)    </p>
<pre><code>  解绑对应的事件
</code></pre><p>  //off(type,&#39;**&#39;)</p>
<pre><code>  解绑所有代理的type事件，元素本身的事件不会被解绑
</code></pre></li>
</ul>
<h3 id="-">事件触发器</h3>
<ul>
<li><p>trigger()</p>
<pre><code>  $(&#39;div&#39;).click(function(){
      $(&#39;p&#39;).trigger(&#39;click&#39;);
  })
  点击div的时候触发p标签的click事件；
</code></pre></li>
<li><p>triggerHandler()</p>
<pre><code>  与trigger()一样，区别是triggerHandler触发对应事件目标事件的时候，不会触发其默认行为；
</code></pre></li>
</ul>
<h3 id="each-">each()方法</h3>
<pre><code>    each()是jQuery方法，调用的时候要用jQuery对象来调用
        $ele.each(function(index,item){})；
</code></pre><ul>
<li><p>each()遍历数组</p>
<p>  $.each(arr,function(index,item){});</p>
</li>
</ul>
<blockquote>
<p>注意与 数组 的forEach()方法进行区分；forEach(function(item,index){})    //这是DOM对象中的方法</p>
</blockquote>
<p>-each()遍历对象</p>
<pre><code>$.each(obj,function(index,item){});
</code></pre><h3 id="-">多库共存</h3>
<pre><code>    当一个文件中引入多个jQuery文件，那么$符号的使用只会引用最后一个jQuery包里面的，不能使用前面jQuery包里面的$符号；
    这样就使得$符号的冲突；
</code></pre><ul>
<li><p>解除冲突</p>
<ol>
<li><p>$.noConflict()；
将后面的版本的$让出来，使用其他符号代替；
var JD = $.noConflict()//将$符号让出来，有一个返回之后，使用这个返回复制给新的变量；
那么这个变量可以代替$进行使用；</p>
</li>
<li><p>使用自执行函数划分作用域
(function($){ 继续使用$符号和方法给})($)</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>$.fn.jQuery可以检测当前的版本，也就是利用该方法检测当前$是属于哪个库的；</p>
</blockquote>
<h1 id="h5c3">H5C3</h1>
<h2 id="h5">H5</h2>
<pre><code>    低版本的浏览器对HTML5新增的标签是不认识的,默认是不存在;为使得低版本的浏览器对新增的标签兼容，有两种方法：
    1.    使用动态创建元素的方法创建新增的标签，但是创建出来的元素默认是个行内元素；
    2.    使用兼容包，引入插件解决兼容问题；
</code></pre><h3 id="-">新增的一些更具语义化的标签</h3>
<ul>
<li>header/nav/section/aside/article/footer</li>
</ul>
<h3 id="-">智能表单</h3>
<pre><code>&lt;input type=&#39;text&#39;/&gt;
</code></pre><ul>
<li>userName</li>
<li>passWord</li>
<li>email （邮件）</li>
<li>tel （电话号码）</li>
<li>url </li>
<li>number</li>
<li>search</li>
<li>range</li>
<li>color</li>
<li>time</li>
<li>date</li>
<li>datetime</li>
<li>moth</li>
<li>week </li>
</ul>
<h3 id="-">新增表单标签</h3>
<ul>
<li><code>&lt;fieldset&gt;&lt;/fieldset&gt;</code></li>
<li><p><code>&lt;datalist&gt;&lt;/datalist&gt;</code></p>
<pre><code> &lt;input type=&#39;text&#39; list=&#39;datalist&#39;/&gt;
     &lt;datalist id=&#39;datalist&#39;&gt;
         &lt;option&gt;宝马&lt;/option&gt;
     &lt;/datalist&gt;
</code></pre></li>
</ul>
<h3 id="-">新增的表单属性</h3>
<ul>
<li><p>required</p>
<pre><code>  表单中必填的的属性
</code></pre></li>
<li><p>placeholder</p>
<pre><code>  占位符；
</code></pre></li>
<li><p>Autofocus</p>
<pre><code>  自动获取焦点;
</code></pre></li>
<li><p>AutoCompelate = &#39;on/off&#39;</p>
<pre><code>  提示之前输入过的内容
</code></pre></li>
<li><p>pattern</p>
<pre><code>  规定用于验证输入字段的模式；模式指的是正则表达式；
</code></pre></li>
<li><p>multiple</p>
<pre><code>  multiple 属性规定输入字段可选择多个值。
</code></pre></li>
</ul>
<h3 id="-">新增的表单事件</h3>
<ul>
<li><p>oninvalid</p>
<pre><code>  当用户输入内容无效的时候触发的事件；

  oninvalid = function(){ this.setCustomValidity(&#39;输入有误！&#39;)}；
</code></pre></li>
<li><p>oninput</p>
<pre><code>  当用户输入内容时候触发的事件,文本框事件
</code></pre></li>
<li><p>onchange</p>
</li>
</ul>
<h3 id="-api">新增的API</h3>
<ul>
<li><p>document.querySelector()</p>
<pre><code>  只能获取一个元素，不论对象是否是多个，也只会获取第一个元素；
</code></pre></li>
<li><p>document.querySelectorAll()</p>
<pre><code>  类似document.getElementsByTagName();获取到的是一个维数组；
</code></pre></li>
</ul>
<h3 id="-">新媒体标签</h3>
<pre><code>- audio/video
    autoplay/controls/play()/pause()/pasued
</code></pre><h3 id="-">操作类样式</h3>
<ul>
<li><p>ele.classList.add() -- 添加类</p>
<pre><code>  JQ: $().addClass();
  js: ele.className = &#39;&#39; / ele.setAttribute(class,&#39;&#39;);
</code></pre></li>
<li><p>ele.classList.remove() -- 移除类</p>
<pre><code>  JQ： $().removeClass();
  js: ele.className = &#39;&#39;; ele.removeAttribute(class);
</code></pre></li>
<li><p>ele.classList.contains() -- 判断类，返回一个布尔值</p>
<pre><code>  JQ： $().hasClass();// 返回一个布尔值
</code></pre></li>
<li><p>ele.classList.toggle() -- 切换类</p>
<pre><code>  JQ: $().toggleClass()
</code></pre></li>
</ul>
<h3 id="-">自定义属性</h3>
<pre><code>    &lt;div data-url = &#39;aaa&#39;&gt;&lt;/div&gt;
        div.dataset[&#39;url&#39;] = aaa;

    设置属性： data-name = &#39;&#39;
    获取属性： dataset[&#39;name&#39;]
</code></pre><h2 id="css3">css3</h2>
<h3 id="-">选择器</h3>
<ul>
<li><p>属性选择器</p>
<pre><code>  li[class=&#39;box&#39;] -- 选择所有li拥有class为box的标签;
  ele[attr*=val] -- 属性值里包含val字符并且在“任意”位置;
  ele[attr^=val] -- 属性值里包含val字符并且在“开始”位置;
  ele[attr$=val] -- 属性值里包含val字符并且在“结束”位置;
</code></pre></li>
<li><p>伪类选择器</p>
<pre><code>  E:first-child；
  E:last-child；
  E:nth-child(n)；
  E:nth-last-child(n)；
</code></pre></li>
<li><p>伪元素选择器</p>
<pre><code>  :first-letter  //  获取元素下的第一个字符
  :first-line  //  获取元素下的第一行
  :selection  //  文本被选择的状态
</code></pre></li>
<li><p>其他选择器</p>
<pre><code>  ele:checed{}
  ele:selected{}
  ele:disabled{}
</code></pre></li>
</ul>
<h3 id="-">阴影</h3>
<ul>
<li><p>文本阴影</p>
<pre><code>  text-shadow:水平配置偏移  垂直位置偏移  模糊距离  阴影颜色;
</code></pre></li>
<li><p>盒子阴影</p>
<pre><code>  box-shadow:水平位置偏移  垂直位置偏移  模糊距离  阴影大小  阴影颜色  内/外阴影
</code></pre></li>
</ul>
<h3 id="-">边框</h3>
<ul>
<li><p>border-radius : 水平弯曲/垂直弯曲</p>
<pre><code>  边框可以分开设置每个边的弯曲程度;四个参数的方向分别为：上左 上右  下右  下左；
</code></pre></li>
<li><p>border-image : url()  border-image-slice  border-image-repeat;</p>
<ul>
<li>border-image-soure:url();</li>
<li>border-image-slice:10; // 将图片从四边裁切下对应数值的宽度的大小,然后将裁切下的边框图片在border宽度范围内显示;注意数值没有单位！</li>
<li>border-image-repeat //  设置背景平铺；</li>
</ul>
</li>
</ul>
<h3 id="-">背景</h3>
<ul>
<li><p>background:url(),url(),..;</p>
<ul>
<li><p>background-size //  背景图片的大小 contain/cover</p>
</li>
<li><p>background-origin // 背景原点，背景显示的地方 content-box/border-box/padding-box</p>
</li>
<li><p>background-clip // 背景裁切 content-box/border-box/padding-box</p>
</li>
</ul>
</li>
</ul>
<h3 id="-">渐变（颜色的渐变）</h3>
<ul>
<li><p>线性渐变</p>
<pre><code>  background: linear-gradient(to ,color-begin position,color-end position);
          注：to 方向;
</code></pre></li>
<li><p>径向渐变</p>
<pre><code>  background: radial-gradient(radial at pisition,color-begin,color-end);
          注：参数（半径，起始位置，开始颜色，结束颜色）;
</code></pre></li>
</ul>
<h3 id="-transition">过渡 transition</h3>
<pre><code>    transition:过渡的属性  过渡的时间  延迟多少时间;
</code></pre><blockquote>
<p>过渡完成的事件：
transitionend; 一般当做节流阀用；
 ele.addEventListener(&#39;transitionend&#39;,function(){});</p>
</blockquote>
<h3 id="2d-transform">2D转换 transform</h3>
<ul>
<li><p>scale 缩放比例</p>
<pre><code>  transform:scale() // 参数可放两个或一个;
</code></pre></li>
<li><p>translate 移动</p>
<pre><code>  transform:translateX()/translateY()/translateZ();
</code></pre></li>
<li><p>rotate 旋转</p>
<pre><code>  transform:rotate( xxx deg);
  transform-origin: // 旋转中心点；
</code></pre></li>
<li><p>skew 倾斜</p>
<pre><code>  transform:skew() // 两个参数分别为水平方向和垂直方向;
</code></pre></li>
</ul>
<h3 id="3d-">3D 转换</h3>
<ul>
<li><p>perspective (透视)</p>
<pre><code>  近大远小的效果,一般给父元素设置；
</code></pre></li>
<li><p>transform-style: preserve-3d （设置3D效果一定要设置该属性）</p>
<pre><code>  让盒子有一个3D的效果，一般给父元素设置;
</code></pre></li>
<li><p>backface-visibility: visible/hidden (设置背面不可见)</p>
</li>
</ul>
<h3 id="animation-">animation 动画</h3>
<pre><code>    设置动画的步骤:
         1.定义动画
             @keyframes name {
                from{}
                to{}
            }
         2.谁需要进行动画函数  给谁添加animation

    动画的调用:
    aniamtion: name duration dalay animation-iteration-count aniamtion-play-state
</code></pre><ul>
<li><p>animation-name 动画名称</p>
</li>
<li><p>animation-duration 定义动画完成一个周期所需要的时间，以秒或毫秒计 </p>
</li>
<li><p>animation-timing-function 规定动画的速度曲线</p>
<ul>
<li>linear 动画从头到尾的速度是相同的</li>
<li>ease 默认</li>
</ul>
</li>
<li><p>animation-delay 属性定义动画何时开始</p>
</li>
<li><p>animation-iteration-count 属性定义动画的播放次数</p>
<ul>
<li>infinite 规定动画应该无限次播放。</li>
</ul>
</li>
<li><p>animation-direction 属性定义是否应该轮流反向播放动画</p>
<ul>
<li>alternate 动画应该轮流反向播放。</li>
</ul>
</li>
<li><p>animation-fill-mode 属性规定动画在播放之前或之后，其动画效果是否可见</p>
<ul>
<li>forwards 当动画完成后，保持最后一个属性值;</li>
<li>backwards </li>
<li>both</li>
</ul>
</li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>